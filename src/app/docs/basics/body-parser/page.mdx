# Body Parser

Nexy provides comprehensive request body parsing through FastAPI and Pydantic. Unlike traditional frameworks requiring manual parser configuration, Nexy intelligently handles request content based on MIME types and structure.

<Mark>
  Nexy automatically parses JSON, form data, files, and even complex nested structures. Just define your expected schema!
</Mark>

---

## Available Parser Types

### Basic Types
Les types de base constituent les fondements de notre syst√®me de typage. Comme les briques √©l√©mentaires d'une construction, ils nous permettent de repr√©senter les donn√©es les plus simples mais essentielles.

<CodeCard fileName="app/examples/basic_types.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`def POST(
    name: str,           # Pour les cha√Ænes de caract√®res
    age: int,           # Pour les nombres entiers
    height: float,      # Pour les nombres d√©cimaux
    is_active: bool,    # Pour les valeurs bool√©ennes
    raw_data: bytes     # Pour les donn√©es binaires
):
    return {
        "message": f"Utilisateur {name}, {age} ans, {height}m",
        "status": is_active,
        "data_size": len(raw_data)
    }
`}/>
</CodeCard>

### Collections
Les collections nous permettent d'organiser et de structurer nos donn√©es de mani√®re plus complexe, comme un architecte assemblant diff√©rents √©l√©ments pour cr√©er un tout coh√©rent.

<CodeCard fileName="app/examples/collections.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from typing import List, Dict, Set, Tuple, Union

def POST(
    tags: List[str],                    # Liste de tags
    metadata: Dict[str, str],           # Dictionnaire de m√©tadonn√©es
    unique_codes: Set[int],             # Ensemble de codes uniques
    coordinates: Tuple[float, float],    # Tuple de coordonn√©es
    value: Union[int, str]              # Union de types possibles
):
    return {
        "tags_count": len(tags),
        "metadata": metadata,
        "codes": list(unique_codes),
        "location": coordinates,
        "dynamic_value": value
    }
`}/>
</CodeCard>

### Special Types
Les types sp√©ciaux nous offrent des outils de validation sophistiqu√©s, garantissant l'int√©grit√© et la coh√©rence de nos donn√©es comme un gardien vigilant.

<CodeCard fileName="app/examples/special_types.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from pydantic import BaseModel, EmailStr, HttpUrl, UUID4
from typing import Optional

class UserProfile(BaseModel):
    id: UUID4
    email: EmailStr
    website: Optional[HttpUrl]
    ip_address: str

def POST(profile: UserProfile):
    return {
        "message": "Profil valid√©",
        "data": profile.model_dump()
    }
`}/>
</CodeCard>

### Time Types
La gestion du temps dans nos applications refl√®te notre rapport au temporel, permettant de capturer et manipuler les moments qui structurent nos donn√©es.

<CodeCard fileName="app/examples/time_types.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from datetime import datetime, date, time, timedelta

def POST(
    created_at: datetime,        # Date et heure compl√®tes
    birth_date: date,           # Date seule
    meeting_time: time,         # Heure seule
    duration: timedelta         # Dur√©e
):
    return {
        "created": created_at.isoformat(),
        "birth": birth_date.isoformat(),
        "meeting": meeting_time.isoformat(),
        "duration_seconds": duration.total_seconds()
    }
`}/>
</CodeCard>

### File Handling
La gestion des fichiers repr√©sente l'interface entre notre application et le monde ext√©rieur, comme un pont permettant l'√©change de donn√©es.

<CodeCard fileName="app/examples/file_handling.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from fastapi import UploadFile
from typing import List

async def POST(
    document: UploadFile,           # Un fichier unique
    attachments: List[UploadFile],  # Multiple fichiers
    binary_data: bytes              # Donn√©es binaires en m√©moire
):
    content = await document.read()
    return {
        "main_file": document.filename,
        "attachments": [f.filename for f in attachments],
        "binary_size": len(binary_data)
    }
`}/>
</CodeCard>

### Form Data
Les formulaires constituent l'interface privil√©gi√©e entre l'utilisateur et notre syst√®me, permettant une interaction structur√©e et valid√©e.

<CodeCard fileName="app/examples/form_data.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from fastapi import Form, File
from typing import Annotated

def POST(
    username: Annotated[str, Form()],
    password: Annotated[str, Form()],
    avatar: Annotated[bytes, File()]
):
    return {
        "username": username,
        "password_length": len(password),
        "avatar_size": len(avatar)
    }
`}/>
</CodeCard>

### Request Metadata
Les m√©tadonn√©es de requ√™te nous permettent de contextualiser et d'enrichir nos interactions, comme des annotations pr√©cieuses guidant notre compr√©hension.

<CodeCard fileName="app/examples/metadata.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from fastapi import Header, Cookie, Query, Path
from typing import Annotated, Optional

def GET(
    user_id: Annotated[int, Path()],                    # Param√®tre d'URL
    token: Annotated[str, Header()],                    # En-t√™te HTTP
    session: Annotated[str, Cookie()],                  # Cookie
    filter: Annotated[str, Query()] = "all"           # Param√®tre de requ√™te
):
    return {
        "user_id": user_id,
        "auth_status": "valid" if token else "invalid",
        "session": session,
        "filter_applied": filter
    }
`}/>
</CodeCard>

---

## Advanced Features

### Validation Rules
La validation des donn√©es est comme un gardien philosophique, assurant que chaque entr√©e respecte les r√®gles √©tablies pour maintenir l'int√©grit√© de notre syst√®me.

<CodeCard fileName="app/examples/validation.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from pydantic import BaseModel, Field, validator
from typing import List

class Article(BaseModel):
    title: str = Field(..., min_length=3, max_length=100)
    content: str = Field(..., min_length=10)
    tags: List[str] = Field(default_factory=list, max_items=5)
    
    @validator('tags')
    def validate_tags(cls, v):
        if not all(len(tag) <= 20 for tag in v):
            raise ValueError('Chaque tag doit faire moins de 20 caract√®res')
        return v

def POST(article: Article):
    return {"status": "Article valid√©", "data": article.model_dump()}
`}/>
</CodeCard>

### Performance Optimization
L'optimisation est un art subtil, √©quilibrant efficacit√© et lisibilit√© pour cr√©er un syst√®me performant et maintenable.

<CodeCard fileName="app/examples/optimization.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from pydantic import BaseModel, Field
from typing import Dict, Any
from functools import lru_cache

class CachedConfig(BaseModel):
    settings: Dict[str, Any] = Field(default_factory=dict)
    
    @lru_cache(maxsize=100)
    def get_setting(self, key: str) -> Any:
        return self.settings.get(key)

async def process_data(data: bytes) -> Dict[str, Any]:
    # Traitement asynchrone optimis√©
    return {"processed": len(data)}
`}/>
</CodeCard>

### Error Handling
La gestion des erreurs est comme une philosophie de la r√©silience, permettant √† notre syst√®me de r√©agir gracieusement aux situations impr√©vues.

<CodeCard fileName="app/examples/error_handling.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from fastapi import HTTPException
from pydantic import BaseModel, ValidationError
from typing import Dict, Any

class CustomError(BaseModel):
    code: str
    message: str
    details: Dict[str, Any] = {}

def handle_validation_error(e: ValidationError) -> CustomError:
    return CustomError(
        code="VALIDATION_ERROR",
        message="Donn√©es invalides",
        details={"errors": e.errors()}
    )

def POST(data: Dict[str, Any]):
    try:
        # Logique m√©tier
        if not data:
            raise HTTPException(status_code=400, detail="Donn√©es requises")
        return {"status": "success"}
    except ValidationError as e:
        return handle_validation_error(e)
`}/>
</CodeCard>

---

## üéØ Key Points

<Mark>
**Automatic Detection**: Nexy d√©tecte intelligemment les types de contenu et applique les parseurs appropri√©s

**Built-in Validation**: Toutes les donn√©es sont valid√©es selon des sch√©mas d√©finis

**Type Safety**: Un typage fort avec conversions automatiques

**Flexible Parsing**: Support pour tous les formats de donn√©es courants

**Error Handling**: D√©tection et rapport d'erreurs complets
</Mark>

Le syst√®me de parsing de Nexy incarne une philosophie de simplicit√© et de puissance - d√©finissez simplement votre structure de donn√©es, et laissez Nexy s'occuper du reste !

<SwitchPage
    prev = { {
        label: "Response",
        href: "/basics/response"
    }}
    next ={ {
        label: "Validation",
        href: "/basics/validation/"
    }}
/>