# Contr√¥leurs

Les contr√¥leurs sont responsables du traitement des demandes entrantes et de l'envoi des r√©ponses au client.

Le r√¥le d'un contr√¥leur est de g√©rer des requ√™tes sp√©cifiques pour l'application. Le m√©canisme de routage d√©termine quel contr√¥leur traitera chaque requ√™te. 

<Mark>
    Dans <Badge>Nexy</Badge>, un contr√¥leur est simplement tout fichier <Badge>controller.py</Badge> situ√© dans le r√©pertoire <Badge>app</Badge> ou ses sous-r√©pertoires. 
</Mark>

<CodeCard fileName="Structure">
  <Structure>
    <Folder folderName="app">
      <Folder folderName="users">
        <File fileName="controller.py"/>
      </Folder>
      <Folder folderName="articles"> 
        <File fileName="controller.py"/>
      </Folder>
      <File fileName="controller.py"/>
    </Folder>
  </Structure>
</CodeCard>

___

## Route

Une route est une association entre un chemin URL et une action dans l'application. Lorsqu'un utilisateur acc√®de √† une URL sp√©cifique, la route correspondante est identifi√©e et ex√©cut√©e pour traiter la demande.
 
Dans <Badge>Nexy</Badge>, une route est d√©finie par la structure de r√©pertoires dans le dossier <Badge>app</Badge>. Le r√©pertoire <Badge>app</Badge> lui-m√™me repr√©sente la route principale, et chaque sous-r√©pertoire d√©finit une route imbriqu√©e.

<CodeCard fileName="Structure">
  <Structure>
    <Folder folderName="app">
      <Folder folderName="users"/>
      <Folder folderName="articles"/> 
    </Folder>
  </Structure>
</CodeCard>

### Route dynamique

Les routes dynamiques permettent d'identifier des ressources sp√©cifiques en utilisant des param√®tres de route. Ces param√®tres sont d√©finis dans le chemin de la route et peuvent √™tre extraits par la fonction de traitement de la route.

Dans <Badge>Nexy</Badge>, une route devient dynamique lorsque le nom du r√©pertoire ou dossier est encadr√© par des crochets, comme ceci : <Badge>[dossier]</Badge>.

<CodeCard fileName="Structure">
  <Structure>
    <Folder folderName="app">
      <Folder folderName="users">
        <Folder folderName="[userId]"/>
      </Folder>
      <Folder folderName="articles">
        <Folder folderName="[articleId]"/>
      </Folder>
        <Folder folderName="[blog]"/>
    </Folder>
  </Structure>
</CodeCard>

<Mark>
  Les routes dynamiques fonctionnent de la m√™me mani√®re pour tous les types d'endpoints.
</Mark>

___

## Endpoint

Un endpoint repr√©sente un point d'interface complet expos√© par l'application qui permet l'interaction avec des services, des ressources ou des fonctionnalit√©s sp√©cifiques. Il comprend :

- <span className="text-amber-50/50 text-sm">‚ë† </span> Le chemin d'acc√®s URL qui identifie la ressource
- <span className="text-amber-50/50 text-sm">‚ë° </span> Le protocole de communication (HTTP ou WebSocket)
- <span className="text-amber-50/50 text-sm">‚ë¢ </span> La fonction de traitement qui g√®re les requ√™tes entrantes

Dans <Badge>Nexy</Badge>, le framework prend en charge deux types d'endpoints principaux :

- <span className="text-amber-50/50 text-sm">‚ë† </span> Les endpoints HTTP
- <span className="text-amber-50/50 text-sm">‚ë° </span> Les endpoints WebSocket

___

## Endpoints HTTP 

Les endpoints HTTP suivent le mod√®le requ√™te-r√©ponse traditionnel et sont utilis√©s pour effectuer des op√©rations CRUD (Create, Read, Update, Delete) sur des ressources.
<Mark>
  Pour cr√©er un endpoint HTTP dans <Badge>Nexy</Badge>, il suffit de d√©finir une fonction ( asynchrone ou pas comme dans <MDXLink href="https://fastapi.tiangolo.com/async/#concurrent-burgers">FastAPI</MDXLink> ) dont le nom correspond √† la m√©thode HTTP souhait√©e (<Badge>GET</Badge>, <Badge>POST</Badge>, <Badge>PUT</Badge>, <Badge>DELETE</Badge>, etc.) dans un fichier <Badge>controller.py</Badge>.
</Mark>

### GET

La m√©thode GET est la m√©thode fondamentale de r√©cup√©ration de donn√©es. Elle permet de lire des informations sans modifier l'√©tat du serveur, 
ce qui en fait la m√©thode la plus s√©curis√©e et la plus utilis√©e. 

Son utilisation principale concerne l'affichage des pages et la consultation des ressources comme les profils utilisateurs ou les listes de produits.


<CodeCard fileName="app/**/controller.py">
<Code language="python"
theme="catppuccin-mocha"
code = {
`from typing import Dict

def GET() -> Dict[str, str] :
    return {"message":"Salut Espoir Lo√©m"}
`
}
/>

</CodeCard>

Dans une route dynamique, il est possible d'extraire les param√®tres de la route en utilisant le nom de la route dynamique comme param√®tre de la fonction .

<CodeCard fileName="app/users/[userId]/controller.py">
<Structure>
    <Folder folderName="app">
      <Folder folderName="users">
        <Folder folderName="[userId]">
          <File fileName="controller.py"/>
        </Folder>
      </Folder>
    </Folder>
  </Structure>
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from typing import Dict

def GET(userId : int) -> Dict[str, str] :
    users = ["Espoir Lo√©m", "Force Espoir","LOEMBA PACKA"]
    return {"user": users[userId]}
`
}
/>
</CodeCard>

### POST

Compl√©mentaire √† GET, la m√©thode POST est d√©di√©e √† la cr√©ation de nouvelles ressources. Elle assure un transfert s√©curis√© des donn√©es vers le serveur, avec une validation syst√©matique avant sauvegarde. 

Cette m√©thode est essentielle pour toutes les op√©rations d'ajout, que ce soit la cr√©ation de comptes utilisateurs ou la publication de nouveaux contenus.

<CodeCard fileName="app/**/controller.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from typing import Dict, List

userList : List[Dict[str, str]] = None

def POST() -> List[Dict[str, str]] :
    userList.append({"name":"Espoir Lo√©m", "nationality":"Congolese"})
    return userList
`
}
/>
</CodeCard>

Dans une route dynamique 

<CodeCard fileName="app/users/[userId]/controller.py">
<Structure>
    <Folder folderName="app">
      <Folder folderName="users">
        <Folder folderName="[userId]">
          <File fileName="controller.py"/>
        </Folder>
      </Folder>
    </Folder>
  </Structure>
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import Request, Depends
from .service import AppService

async def POST(
      userId: int,
      service: Depends(AppService),
      request: Request,
    ) -> Dict[str, str]:

    comment_data = await request.json()
    data = await service.add_comment(userId, comment_data)

    return data
`
}
/>
</CodeCard>


<Mark>
  Not√© que Nexy supporte les Methode HTTP suivant :
  <MDXLink href="https://developer.mozilla.org/docs/Web/HTTP/Methods/GET"><Badge>GET</Badge></MDXLink>
  <MDXLink href="https://developer.mozilla.org/docs/Web/HTTP/Methods/POST"><Badge>POST</Badge></MDXLink>
  <MDXLink href="https://developer.mozilla.org/docs/Web/HTTP/Methods/PUT"><Badge>PUT</Badge></MDXLink>
  <MDXLink href="https://developer.mozilla.org/docs/Web/HTTP/Methods/DELETE"><Badge>DELETE</Badge></MDXLink>
  <MDXLink href="https://developer.mozilla.org/docs/Web/HTTP/Methods/OPTIONS"><Badge>OPTIONS</Badge></MDXLink>
  <MDXLink href="https://developer.mozilla.org/docs/Web/HTTP/Methods/HEAD"><Badge>HEAD</Badge></MDXLink>
  <MDXLink href="https://developer.mozilla.org/docs/Web/HTTP/Methods/PATCH"><Badge>PATCH</Badge></MDXLink>
  <MDXLink href="https://developer.mozilla.org/docs/Web/HTTP/Methods/TRACE"><Badge>TRACE</Badge></MDXLink>

</Mark>
Chaque endpoint HTTP est caract√©ris√© par :
- <span className="text-amber-50/50 text-sm">‚ë† </span> une communication ponctuelle et sans √©tat
- <span className="text-amber-50/50 text-sm">‚ë° </span> l'utilisation d'une m√©thode HTTP sp√©cifique
- <span className="text-amber-50/50 text-sm">‚ë¢ </span> une structure de donn√©es d'entr√©e et de sortie bien d√©finie

___

## Endpoints WebSocket

Les endpoints WebSocket √©tablissent une connexion persistante et bidirectionnelle entre le client et le serveur, permettant des communications en temps r√©el.

Ces endpoints sont particuli√®rement adapt√©s pour :
- <span className="text-amber-50/50 text-sm">‚ë† </span> Les applications n√©cessitant des mises √† jour instantan√©es
- <span className="text-amber-50/50 text-sm">‚ë° </span> Les fonctionnalit√©s de chat et de messagerie
- <span className="text-amber-50/50 text-sm">‚ë¢ </span> Les tableaux de bord en temps r√©el
- <span className="text-amber-50/50 text-sm">‚ë£ </span> Les notifications push

Un endpoint WebSocket dans <Badge>Nexy</Badge> maintient un √©tat de connexion et permet l'envoi de messages dans les deux sens √† tout moment, contrairement aux endpoints HTTP qui suivent un strict mod√®le de requ√™te-r√©ponse.

### Comment cr√©er un endpoint WebSocket ?
Tout comme pour les endpoints HTTP, il suffit de cr√©er une fonction asynchrone nomm√©e <Badge>SOCKET</Badge>  dans un fichier <Badge>controller.py</Badge>.


<CodeCard fileName="app/**/controller.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import WebSocket

async def SOCKET(ws: WebSocket):
    await ws.accept()  # Accept the WebSocket connection
    
    try:
        while True:
            # Receive message from client
            message = await ws.receive_text()
            
            # Echo the message back
            await ws.send_text(f"Server received: {message}")
            
    except Exception:
        await ws.close()
`
}
/>


</CodeCard>



Tout comme pour les endpoints HTTP, il est possible d'extraire les param√®tres de la route en utilisant le nom de la route dynamique comme param√®tre de la fonction.

<CodeCard fileName="app/users/[userId]/controller.py">
<Structure>
    <Folder folderName="app">
      <Folder folderName="users">
        <Folder folderName="[userId]">
          <File fileName="controller.py"/>
        </Folder>
      </Folder>
    </Folder>
  </Structure>
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import WebSocket

async def SOCKET(userId: int, ws: WebSocket):  
    await ws.accept()
    await ws.send_text(f"Hello user {userId}")
    await ws.close()
` 
}
/>
</CodeCard>

___

## üëå Bravo !
Maintenant que vous avez appris √† propos des contr√¥leurs et des endpoints, vous pouvez commencer √† construire la structure API de votre application !
D√©couvrons comment faire cela dans la section suivante.
<SwitchPage
    prev = { {
        label: "Guidee de contruction",
        href: "/started/"
    }}
    next ={ {
        label: "Installation",
        href: "/started/"
    }}

/>