# Request

L'objet de la classe <Badge>Request</Badge> dans Nexy est votre interface principale pour accÃ©der aux donnÃ©es des requÃªtes HTTP entrantes. HÃ©ritant directement de FastAPI, il vous offre un accÃ¨s complet et simplifiÃ© aux en-tÃªtes, paramÃ¨tres, corps de requÃªte et fichiers tÃ©lÃ©chargÃ©s.

### CompatibilitÃ© FastAPI

La classe <Badge>Request</Badge> dans Nexy hÃ©rite intÃ©gralement de FastAPI, garantissant une compatibilitÃ© totale avec l'Ã©cosystÃ¨me FastAPI existant.

<Mark>
  ğŸ’¡ Astuce : Un objet de la classe <Badge>Request</Badge>  est automatiquement injectÃ© dans vos contrÃ´leurs. DÃ©clarez-le simplement comme paramÃ¨tre typÃ© !
</Mark>

---

## AccÃ©der Ã  `Request`

Pour utiliser <Badge>Request</Badge> , il vous suffit de l'ajouter comme paramÃ¨tre dans la dÃ©finition de votre fonction de contrÃ´leur. Voici comment faire :

<CodeCard fileName="app/**/controller.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import Request

async def GET(request: Request):
    # Vous pouvez maintenant utiliser l'objet 'request' ici
    return {"message": "RequÃªte reÃ§ue !"}
`
}
/>
</CodeCard>





___

## AccÃ©der Ã  l'URL de la RequÃªte

Vous pouvez obtenir l'URL complÃ¨te de la requÃªte en utilisant <Badge>request.url</Badge>.

<CodeCard fileName="app/url/controller.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import Request
from typing import Dict

def GET(request: Request) -> Dict[str, str]:
    return {"url_complete": str(request.url)}
`
}
/>
</CodeCard>

___

## ConnaÃ®tre la MÃ©thode HTTP

La mÃ©thode HTTP utilisÃ©e pour la requÃªte (GET, POST, etc.) est disponible via <Badge>request.method</Badge>.

<CodeCard fileName="app/method/controller.py">

<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import Request
from typing import Dict

def GET(request: Request) -> Dict[str, str]:
    return {"methode_http": request.method}
`
}
/>
</CodeCard>

___

## Obtenir l'Adresse IP du Client

L'adresse IP du client qui a envoyÃ© la requÃªte est accessible via <Badge>request.client.host</Badge>.

<CodeCard fileName="app/client/controller.py">

<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import Request
from typing import Dict

def GET(request: Request) -> Dict[str, str]:
    client_host = request.client.host if request.client else "Inconnu"
    return {"adresse_ip_client": client_host}
`
}
/>
</CodeCard>



___

## RÃ©cupÃ©rer les ParamÃ¨tres de Chemin

Les paramÃ¨tres de chemin sont des valeurs qui font partie de l'URL elle-mÃªme (par exemple, <Badge>/utilisateurs/123</Badge> oÃ¹ <Badge>123</Badge> est un paramÃ¨tre). Nexy vous permet de les rÃ©cupÃ©rer directement en les dÃ©clarant comme des paramÃ¨tres de votre fonction de contrÃ´leur.

<CodeCard fileName="app/users/[userId]/controller.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from typing import Dict

def GET(userId: int) -> Dict[str, str]:
    # userId est automatiquement extrait de l'URL
    users = {
        1: "Espoir LoÃ©m",
        2: "Force Espoir",
        3: "LOEMBA PACKA"
    }
    return {"user": users.get(userId, "Utilisateur non trouvÃ©")}
`
}
/>
</CodeCard>

___

## RÃ©cupÃ©rer les ParamÃ¨tres de RequÃªte (Query Parameters)

Les paramÃ¨tres de requÃªte sont des paires clÃ©-valeur ajoutÃ©es Ã  la fin de l'URL aprÃ¨s un point d'interrogation (par exemple, <Badge>/items?name=chaise&quantity=2</Badge>). Vous pouvez y accÃ©der via l'objet <Badge>request.query_params</Badge>.

<CodeCard fileName="app/items/controller.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import Request
from typing import Dict

def GET(request: Request) -> Dict[str, str]:
    name = request.query_params.get("name")
    quantity = request.query_params.get("quantity")
    return {"nom": name, "quantite": quantity}
`
}
/>
</CodeCard>

Il est Ã©galement possible de rÃ©cupÃ©rer les paramÃ¨tres de requÃªte en les dÃ©clarant directement comme paramÃ¨tres dans votre fonction de contrÃ´leur.

<CodeCard fileName="app/items/controller.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from typing import Dict

def GET(name: str, quantity: int) -> Dict[str, str]:
    return {"nom": name, "quantite": quantity}
` 
}
/>
</CodeCard>


___

## Lire le Corps de la RequÃªte (JSON)

Pour les requÃªtes <Badge>POST</Badge>, <Badge>PUT</Badge>, <Badge>PATCH</Badge> qui envoient des donnÃ©es au format JSON, vous pouvez lire le corps de la requÃªte de maniÃ¨re asynchrone en utilisant <Badge>await request.json()</Badge>.

<CodeCard fileName="app/data/controller.py">

<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import Request
from typing import Dict

async def POST(request: Request) -> Dict[str, str]:
    data = await request.json() # Lit le corps de la requÃªte comme du JSON
    return {"message": "DonnÃ©es JSON reÃ§ues !", "donnees": data}
`}/>
</CodeCard>

___

## Lire le Corps de la RequÃªte (DonnÃ©es de Formulaire)

Pour les requÃªtes qui envoient des donnÃ©es de formulaire (par exemple,<br/> <Badge>application/x-www-form-urlencoded</Badge> ou <Badge>multipart/form-data</Badge>), vous pouvez utiliser <Badge>await request.form()</Badge>.

<CodeCard fileName="app/form/controller.py">

<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import Request
from typing import Dict

async def POST(request: Request) -> Dict[str, str]:
    # Lit le corps de la requÃªte comme des donnÃ©es de formulaire
    form_data = await request.form() 
    username = form_data.get("username")
    password = form_data.get("password")
    return {
        "message": "DonnÃ©es de formulaire reÃ§ues !",
        "username": username,
        "password": password
    }
`
}
/>
</CodeCard>

___

## AccÃ©der aux En-tÃªtes de RequÃªte

Les en-tÃªtes HTTP sont accessibles via <Badge>request.headers</Badge>. C'est un dictionnaire insensible Ã  la casse.

<CodeCard fileName="app/headers/controller.py">

<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import Request
from typing import Dict

def GET(request: Request) -> Dict[str, str]:
    user_agent = request.headers.get("user-agent")
    content_type = request.headers.get("content-type")
    return {"user_agent": user_agent, "content_type": content_type}
`
}
/>
</CodeCard>

___

## AccÃ©der aux Cookies

Les cookies envoyÃ©s avec la requÃªte sont accessibles via <Badge>request.cookies</Badge>. C'est un dictionnaire simple.

<CodeCard fileName="app/cookies/controller.py">

<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import Request
from typing import Dict

def GET(request: Request) -> Dict[str, str]:
    session_id = request.cookies.get("session_id")
    return {"session_id": session_id}
`
}
/>
</CodeCard>

___

## GÃ©rer les Fichiers TÃ©lÃ©chargÃ©s

Pour gÃ©rer les fichiers tÃ©lÃ©chargÃ©s via un formulaire <Badge>multipart/form-data</Badge>, vous pouvez accÃ©der aux fichiers via l'objet <Badge>form_data</Badge> retournÃ© par <Badge>await request.form()</Badge>.
<CodeCard fileName="app/upload/controller.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import Request
from typing import Dict

async def POST(request: Request) -> Dict[str, str]:
    form_data = await request.form()
    upload_file = form_data.get("upload_file")

    if upload_file and upload_file.filename:
        # Pour un fichier, vous pouvez lire son contenu
        content = await upload_file.read()
        filename = upload_file.filename
        return {"nom": filename, "taille": len(content)}
    return {"message": "Aucun fichier n'a Ã©tÃ© tÃ©lÃ©chargÃ©"}
`
}
/>
</CodeCard>

---

## AccÃ©der au Contexte de la RequÃªte ( request.scope )

L'attribut <Badge>request.scope</Badge> est un dictionnaire qui contient le contexte de la requÃªte ASGI (Asynchronous Server Gateway Interface). Il inclut des informations de bas niveau sur la connexion, telles que le type de protocole, l'adresse du client et du serveur, etc.

<CodeCard fileName="app/scope/controller.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import Request
from typing import Dict

def GET(request: Request) -> Dict[str, str]:
    # Par exemple, vous pouvez obtenir le type de scope
    scope_type = request.scope.get("type")
    return {"scope_type": scope_type}
`
}
/>
</CodeCard>

---

## AccÃ©der Ã  l'Application ASGI ( request.app )

L'attribut <Badge>request.app</Badge> fait rÃ©fÃ©rence Ã  l'application ASGI principale qui gÃ¨re la requÃªte. Dans la plupart des cas, il s'agit de votre instance d'application Nexy.

<CodeCard fileName="app/app_instance/controller.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import Request
from typing import Dict

def GET(request: Request) -> Dict[str, str]:
    # Vous pouvez vÃ©rifier si l'objet app est prÃ©sent
    app_present = bool(request.app)
    return {"app_instance_present": app_present}
`
}
/>
</CodeCard>

---

## Obtenir l'URL de Base ( request.base_url )

L'attribut <Badge>request.base_url</Badge> fournit l'URL de base de l'application, sans le chemin spÃ©cifique de la requÃªte. C'est utile pour construire des URLs absolues.

<CodeCard fileName="app/base_url/controller.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import Request
from typing import Dict

def GET(request: Request) -> Dict[str, str]:
    base_url = str(request.base_url)
    return {"base_url": base_url}
`
}
/>
</CodeCard>

---

## AccÃ©der aux Informations du Client (`request.client`)

L'attribut <Badge>request.client</Badge> est un objet <Badge>Host</Badge> contenant l'adresse IP et le port du client. Nous avons dÃ©jÃ  vu <Badge>request.client.host</Badge>.

<CodeCard fileName="app/client_info/controller.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import Request
from typing import Dict

def GET(request: Request) -> Dict[str, str]:
    client_port = request.client.port if request.client else "Inconnu"
    return {"client_port": client_port}
`
}
/>
</CodeCard>

---

## GÃ©rer les Sessions ( request.session )

Si vous utilisez une gestion de session (par exemple, via des middlewares), l'attribut <Badge>request.session</Badge> vous permet d'accÃ©der aux donnÃ©es de la session en cours. Notez que cela nÃ©cessite une configuration de session.

<CodeCard fileName="app/session/controller.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import Request
from typing import Dict

def GET(request: Request) -> Dict[str, str]:
    # AccÃ©der aux donnÃ©es de la session
    user_id = request.session.get("user_id", "Non connectÃ©")
    return {"session_user_id": user_id}
`
}
/>
</CodeCard>

---

## Informations d'Authentification (request.auth et request.user)

Si vous utilisez un systÃ¨me d'authentification, <Badge>request.auth</Badge> et <Badge>request.user</Badge> contiendront les informations d'authentification et l'objet utilisateur authentifiÃ©, respectivement. Ces attributs sont gÃ©nÃ©ralement dÃ©finis par des middlewares d'authentification.

<CodeCard fileName="app/auth_user/controller.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import Request
from typing import Dict

def GET(request: Request) -> Dict[str, str]:
    # VÃ©rifier si un utilisateur est authentifiÃ©
    username = request.user.display_name if request.user else "InvitÃ©"
    return {"current_user": username}
`
}
/>
</CodeCard>

---

## Ã‰tat de la RequÃªte ( request.state )

L'attribut <Badge>request.state</Badge> est un dictionnaire que vous pouvez utiliser pour stocker des informations arbitraires liÃ©es Ã  la requÃªte, accessibles tout au long de son cycle de vie (par exemple, dans les middlewares ou les dÃ©pendances).

<CodeCard fileName="app/state/controller.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import Request
from typing import Dict

def GET(request: Request) -> Dict[str, str]:
    # DÃ©finir une valeur dans l'Ã©tat de la requÃªte
    request.state.custom_data = "Ceci est une donnÃ©e personnalisÃ©e"
    # RÃ©cupÃ©rer une valeur de l'Ã©tat de la requÃªte
    data = request.state.get("custom_data")
    return {"request_state_data": data}
`
}
/>
</CodeCard>

---

## Recevoir des DonnÃ©es Brutes ( request.receive )

La mÃ©thode <Badge>request.receive()</Badge> est une coroutine de bas niveau utilisÃ©e pour recevoir des Ã©vÃ©nements ASGI. Elle est principalement utilisÃ©e en interne par Nexy / FastAPI / Starlette pour lire le corps de la requÃªte, mais vous pouvez l'utiliser pour des cas d'utilisation avancÃ©s.

<CodeCard fileName="app/receive/controller.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import Request
from typing import Dict

async def POST(request: Request) -> Dict[str, str]:
    # Exemple trÃ¨s bas niveau de lecture du corps de la requÃªte
    # PrÃ©fÃ©rer request.json() ou request.form() pour la plupart des cas
    body_chunks = []
    async for chunk in request.stream():
        body_chunks.append(chunk)
    raw_body = b"".join(body_chunks).decode("utf-8")
    return {"raw_body_received": raw_body}
`
}
/>
</CodeCard>

---

## GÃ©nÃ©rer des URLs ( request.url_for )

La mÃ©thode <Badge>request.url_for()</Badge> permet de gÃ©nÃ©rer des URLs pour des routes nommÃ©es. C'est trÃ¨s utile pour construire des liens dynamiques dans votre application.

<CodeCard fileName="app/url_for/controller.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import Request
from typing import Dict

def GET(request: Request) -> Dict[str, str]:
    # GÃ©nÃ©rer une URL pour une route nommÃ©e
    profile_url = request.url_for("user_profile", user_id=123)
    # profile_url = "/users/123"  Exemple statique pour l'illustration
    return {"user_profile_url": profile_url}
`
}
/>
</CodeCard>

---

## Lire le Corps de la RequÃªte en Streaming ( request.stream )

La mÃ©thode <Badge>request.stream()</Badge> est une coroutine asynchrone qui renvoie un itÃ©rateur asynchrone sur les morceaux (chunks) du corps de la requÃªte. C'est utile pour gÃ©rer de trÃ¨s gros fichiers ou des flux de donnÃ©es.

<CodeCard fileName="app/stream/controller.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import Request
from typing import Dict

async def POST(request: Request) -> Dict[str, str]:
    total_size = 0
    async for chunk in request.stream():
        total_size += len(chunk)
    return {"bytes_received_via_stream": total_size}
`
}
/>
</CodeCard>

---

## AccÃ©der au Corps de la RequÃªte Brute ( request.body )

La mÃ©thode <Badge>request.body()</Badge> est une coroutine qui lit l'intÃ©gralitÃ© du corps de la requÃªte et le renvoie sous forme d'octets. 
Une fois lu, le corps ne peut pas Ãªtre relu par d'autres mÃ©thodes comme <Badge>request.json()</Badge> ou <Badge>request.form()</Badge>.

<CodeCard fileName="app/body/controller.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import Request
from typing import Dict

async def POST(request: Request) -> Dict[str, str]:
    raw_body = await request.body()
    reponse = {
        "raw_body_length": len(raw_body), 
        "raw_body_preview": raw_body.decode("utf-8")[:50]
    }
    return  reponse
`
}
/>
</CodeCard>

---

## VÃ©rifier la DÃ©connexion du Client ( request.is_disconnected )

La mÃ©thode <Badge>request.is_disconnected()</Badge> permet de vÃ©rifier si le client s'est dÃ©connectÃ© pendant le traitement de la requÃªte. C'est utile pour les opÃ©rations longues.

<CodeCard fileName="app/disconnected/controller.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import Request
from typing import Dict
import asyncio

async def GET(request: Request) -> Dict[str, str]:
    await asyncio.sleep(1) # Simuler un travail long
    if await request.is_disconnected():
        return {"status": "Client dÃ©connectÃ©"}
    return {"status": "Client toujours connectÃ©"}
`
}
/>
</CodeCard>

---

## Fermer la Connexion ( request.close )

La mÃ©thode <Badge>request.close()</Badge> est une coroutine qui peut Ãªtre utilisÃ©e pour signaler que la connexion doit Ãªtre fermÃ©e. Elle est rarement appelÃ©e directement par l'utilisateur.

<CodeCard fileName="app/close/controller.py">
<Code language="python"
 theme="catppuccin-mocha"
code = {
`from nexy import Request
from typing import Dict

async def GET(request: Request) -> Dict[str, str]:
    La mÃ©thode request.close().
    # Il est rare de devoir l'appeler manuellement 
    # dans votre code d'application.
    return {"message": "La mÃ©thode close est gÃ©rÃ©e par le serveur ASGI."}
`
}
/>
</CodeCard>

---

## ğŸ‘Œ Bravo !

Vous avez maintenant une comprÃ©hension trÃ¨s complÃ¨te de l'objet <Badge>Request</Badge> et de toutes ses fonctionnalitÃ©s dans Nexy, grÃ¢ce Ã  son hÃ©ritage de FastAPI. Vous Ãªtes prÃªt Ã  manipuler les donnÃ©es entrantes de vos applications de maniÃ¨re avancÃ©e !

Pour aller plus loin : Consultez la <MDXLink href="https://fastapi.tiangolo.com/tutorial/request/">documentation FastAPI</MDXLink> pour dÃ©couvrir toutes les fonctionnalitÃ©s hÃ©ritÃ©es disponibles dans Nexy.

<SwitchPage
    prev = { {
        label: "ContrÃ´leurs",
        href: "/basics/controllers/"
    }}
    next ={ {
        label: "RÃ©ponses",
        href: "/basics/response"
    }}

/>

